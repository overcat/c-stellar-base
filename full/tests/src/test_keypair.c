#include <setjmp.h>
#include <stdarg.h>
#include <stddef.h>

#include "../../src/keypair.h"
#include "../../src/strkey.h"
#include <cmocka.h>

void test_keypair_from_seed(void **state) {
  uint8_t seed[] = {0x0,  0xf2, 0x10, 0x94, 0x3e, 0xae, 0xb,  0x3a,
                    0x60, 0x86, 0xab, 0x39, 0x0,  0xa1, 0x23, 0xb2,
                    0xd4, 0x87, 0x8,  0xf6, 0xdf, 0xa9, 0xf6, 0x11,
                    0x62, 0xcd, 0xa7, 0xce, 0x41, 0xf4, 0xce, 0x7a};
  struct Keypair keypair;
  assert_true(keypair_from_seed(&keypair, seed));
  struct Keypair expected_keypair = {
      .seed = {0x0,  0xf2, 0x10, 0x94, 0x3e, 0xae, 0xb,  0x3a, 0x60, 0x86, 0xab,
               0x39, 0x0,  0xa1, 0x23, 0xb2, 0xd4, 0x87, 0x8,  0xf6, 0xdf, 0xa9,
               0xf6, 0x11, 0x62, 0xcd, 0xa7, 0xce, 0x41, 0xf4, 0xce, 0x7a},
      .public_key = {0x6d, 0xad, 0xcd, 0xfb, 0x9e, 0x98, 0x5b, 0xd,
                     0xc3, 0x21, 0xcb, 0x7d, 0x67, 0xf5, 0x64, 0x43,
                     0xfc, 0x3e, 0x7b, 0x2a, 0x6f, 0x21, 0xae, 0x36,
                     0x21, 0xed, 0x43, 0x6f, 0xff, 0xf8, 0xc9, 0x53},
      .can_sign = true};
  assert_true(keypair.can_sign);
  assert_memory_equal(keypair.seed, expected_keypair.seed, 32);
  assert_memory_equal(keypair.public_key, expected_keypair.public_key, 32);
}

void test_keypair_from_secret(void **state) {
  char *seed = "SAAPEEEUH2XAWOTAQ2VTSAFBEOZNJBYI63P2T5QRMLG2PTSB6THHUZXS";
  struct Keypair keypair;
  assert_true(keypair_from_secret(&keypair, seed));
  struct Keypair expected_keypair = {
      .seed = {0x0,  0xf2, 0x10, 0x94, 0x3e, 0xae, 0xb,  0x3a, 0x60, 0x86, 0xab,
               0x39, 0x0,  0xa1, 0x23, 0xb2, 0xd4, 0x87, 0x8,  0xf6, 0xdf, 0xa9,
               0xf6, 0x11, 0x62, 0xcd, 0xa7, 0xce, 0x41, 0xf4, 0xce, 0x7a},
      .public_key = {0x6d, 0xad, 0xcd, 0xfb, 0x9e, 0x98, 0x5b, 0xd,
                     0xc3, 0x21, 0xcb, 0x7d, 0x67, 0xf5, 0x64, 0x43,
                     0xfc, 0x3e, 0x7b, 0x2a, 0x6f, 0x21, 0xae, 0x36,
                     0x21, 0xed, 0x43, 0x6f, 0xff, 0xf8, 0xc9, 0x53},
      .can_sign = true};
  assert_true(keypair.can_sign);
  assert_memory_equal(keypair.seed, expected_keypair.seed, 32);
  assert_memory_equal(keypair.public_key, expected_keypair.public_key, 32);
}

void test_keypair_from_address(void **state) {
  char *address = "GBW23TP3T2MFWDODEHFX2Z7VMRB7YPT3FJXSDLRWEHWUG3777DEVGRVD";
  struct Keypair keypair;
  assert_true(keypair_from_address(&keypair, address));
  struct Keypair expected_keypair = {
      .public_key = {0x6d, 0xad, 0xcd, 0xfb, 0x9e, 0x98, 0x5b, 0xd,
                     0xc3, 0x21, 0xcb, 0x7d, 0x67, 0xf5, 0x64, 0x43,
                     0xfc, 0x3e, 0x7b, 0x2a, 0x6f, 0x21, 0xae, 0x36,
                     0x21, 0xed, 0x43, 0x6f, 0xff, 0xf8, 0xc9, 0x53},
      .can_sign = false};
  assert_true(!keypair.can_sign);
  assert_memory_equal(keypair.public_key, expected_keypair.public_key, 32);
}

void test_keypair_random(void **state) {
  struct Keypair keypair;
  assert_true(keypair_random(&keypair));
  assert_true(keypair.can_sign);
}

void test_keypair_address(void **state) {
  struct Keypair keypair = {
      .public_key = {0x6d, 0xad, 0xcd, 0xfb, 0x9e, 0x98, 0x5b, 0xd,
                     0xc3, 0x21, 0xcb, 0x7d, 0x67, 0xf5, 0x64, 0x43,
                     0xfc, 0x3e, 0x7b, 0x2a, 0x6f, 0x21, 0xae, 0x36,
                     0x21, 0xed, 0x43, 0x6f, 0xff, 0xf8, 0xc9, 0x53},
      .can_sign = false};
  char address[ED25519_PUBLIC_KEY_LENGTH + 1];
  assert_true(keypair_address(&keypair, address));
  char *expected_address =
      "GBW23TP3T2MFWDODEHFX2Z7VMRB7YPT3FJXSDLRWEHWUG3777DEVGRVD";
  assert_string_equal(expected_address, address);
}

void test_keypair_secret(void **state) {
  struct Keypair keypair = {
      .seed = {0x0,  0xf2, 0x10, 0x94, 0x3e, 0xae, 0xb,  0x3a, 0x60, 0x86, 0xab,
               0x39, 0x0,  0xa1, 0x23, 0xb2, 0xd4, 0x87, 0x8,  0xf6, 0xdf, 0xa9,
               0xf6, 0x11, 0x62, 0xcd, 0xa7, 0xce, 0x41, 0xf4, 0xce, 0x7a},
      .public_key = {0x6d, 0xad, 0xcd, 0xfb, 0x9e, 0x98, 0x5b, 0xd,
                     0xc3, 0x21, 0xcb, 0x7d, 0x67, 0xf5, 0x64, 0x43,
                     0xfc, 0x3e, 0x7b, 0x2a, 0x6f, 0x21, 0xae, 0x36,
                     0x21, 0xed, 0x43, 0x6f, 0xff, 0xf8, 0xc9, 0x53},
      .can_sign = true};
  char secret[ED25519_SECRET_SEED_LENGTH + 1];
  assert_true(keypair_secret(&keypair, secret));
  char *expected_secret =
      "SAAPEEEUH2XAWOTAQ2VTSAFBEOZNJBYI63P2T5QRMLG2PTSB6THHUZXS";
  assert_string_equal(expected_secret, secret);
}

void test_keypair_sign(void **state) {
  struct Keypair keypair = {
      .seed = {0x0,  0xf2, 0x10, 0x94, 0x3e, 0xae, 0xb,  0x3a, 0x60, 0x86, 0xab,
               0x39, 0x0,  0xa1, 0x23, 0xb2, 0xd4, 0x87, 0x8,  0xf6, 0xdf, 0xa9,
               0xf6, 0x11, 0x62, 0xcd, 0xa7, 0xce, 0x41, 0xf4, 0xce, 0x7a},
      .public_key = {0x6d, 0xad, 0xcd, 0xfb, 0x9e, 0x98, 0x5b, 0xd,
                     0xc3, 0x21, 0xcb, 0x7d, 0x67, 0xf5, 0x64, 0x43,
                     0xfc, 0x3e, 0x7b, 0x2a, 0x6f, 0x21, 0xae, 0x36,
                     0x21, 0xed, 0x43, 0x6f, 0xff, 0xf8, 0xc9, 0x53},
      .can_sign = true};
  uint8_t signature[64];
  char *message = "Hello, Stellar.";
  size_t message_len = strlen(message);
  assert_true(
      keypair_sign(&keypair, signature, (unsigned char *)message, message_len));
  uint8_t expect_signature[64] = {
      0x80, 0xa2, 0x48, 0x5a, 0x60, 0xa2, 0xd1, 0xba, 0x1d, 0xa6, 0x6f,
      0xbd, 0xd9, 0x1a, 0x6b, 0x92, 0x61, 0x38, 0xbb, 0x56, 0x36, 0xf6,
      0xbe, 0xb6, 0x47, 0x1f, 0xbd, 0x12, 0x71, 0x4,  0xf5, 0x89, 0x2c,
      0xec, 0xb3, 0x4,  0xf8, 0x6e, 0xa,  0x51, 0xbf, 0x55, 0x41, 0x35,
      0x3a, 0x6b, 0x99, 0xb9, 0x32, 0xb3, 0x50, 0x1,  0x17, 0x46, 0x41,
      0x72, 0xb3, 0x4d, 0x14, 0x14, 0x92, 0xe9, 0x20, 0x1};
  assert_memory_equal(signature, expect_signature, 64);
}

void test_keypair_verify(void **state) {
  struct Keypair keypair = {
      .seed = {0x0,  0xf2, 0x10, 0x94, 0x3e, 0xae, 0xb,  0x3a, 0x60, 0x86, 0xab,
               0x39, 0x0,  0xa1, 0x23, 0xb2, 0xd4, 0x87, 0x8,  0xf6, 0xdf, 0xa9,
               0xf6, 0x11, 0x62, 0xcd, 0xa7, 0xce, 0x41, 0xf4, 0xce, 0x7a},
      .public_key = {0x6d, 0xad, 0xcd, 0xfb, 0x9e, 0x98, 0x5b, 0xd,
                     0xc3, 0x21, 0xcb, 0x7d, 0x67, 0xf5, 0x64, 0x43,
                     0xfc, 0x3e, 0x7b, 0x2a, 0x6f, 0x21, 0xae, 0x36,
                     0x21, 0xed, 0x43, 0x6f, 0xff, 0xf8, 0xc9, 0x53},
      .can_sign = true};
  uint8_t signature[64] = {
      0x80, 0xa2, 0x48, 0x5a, 0x60, 0xa2, 0xd1, 0xba, 0x1d, 0xa6, 0x6f,
      0xbd, 0xd9, 0x1a, 0x6b, 0x92, 0x61, 0x38, 0xbb, 0x56, 0x36, 0xf6,
      0xbe, 0xb6, 0x47, 0x1f, 0xbd, 0x12, 0x71, 0x4,  0xf5, 0x89, 0x2c,
      0xec, 0xb3, 0x4,  0xf8, 0x6e, 0xa,  0x51, 0xbf, 0x55, 0x41, 0x35,
      0x3a, 0x6b, 0x99, 0xb9, 0x32, 0xb3, 0x50, 0x1,  0x17, 0x46, 0x41,
      0x72, 0xb3, 0x4d, 0x14, 0x14, 0x92, 0xe9, 0x20, 0x1};
  char *message = "Hello, Stellar.";
  size_t message_len = strlen(message);
  assert_true(keypair_verify(&keypair, signature, (unsigned char *)message,
                             message_len));
}

void test_keypair_verify_failed(void **state) {
  struct Keypair keypair = {
      .seed = {0x0,  0xf2, 0x10, 0x94, 0x3e, 0xae, 0xb,  0x3a, 0x60, 0x86, 0xab,
               0x39, 0x0,  0xa1, 0x23, 0xb2, 0xd4, 0x87, 0x8,  0xf6, 0xdf, 0xa9,
               0xf6, 0x11, 0x62, 0xcd, 0xa7, 0xce, 0x41, 0xf4, 0xce, 0x7a},
      .public_key = {0x6d, 0xad, 0xcd, 0xfb, 0x9e, 0x98, 0x5b, 0xd,
                     0xc3, 0x21, 0xcb, 0x7d, 0x67, 0xf5, 0x64, 0x43,
                     0xfc, 0x3e, 0x7b, 0x2a, 0x6f, 0x21, 0xae, 0x36,
                     0x21, 0xed, 0x43, 0x6f, 0xff, 0xf8, 0xc9, 0x53},
      .can_sign = true};
  uint8_t signature[64] = {
      0x80, 0xa2, 0x48, 0x5a, 0x60, 0xa2, 0xd1, 0xba, 0x1d, 0xa6, 0x6f,
      0xbd, 0xd9, 0x1a, 0x6b, 0x92, 0x61, 0x38, 0xbb, 0x56, 0x36, 0xf6,
      0xbe, 0xb6, 0x47, 0x1f, 0xbd, 0x12, 0x71, 0x4,  0xf5, 0x89, 0x2c,
      0xec, 0xb3, 0x4,  0xf8, 0x6e, 0xa,  0x51, 0xbf, 0x55, 0x41, 0x35,
      0x3a, 0x6b, 0x99, 0xb9, 0x32, 0xb3, 0x50, 0x1,  0x17, 0x46, 0x41,
      0x72, 0xb3, 0x4d, 0x14, 0x14, 0x92, 0xe9, 0x20, 0x1};
  char *message = "Hello, Stellar. Invalid.";
  size_t message_len = strlen(message);
  assert_false(keypair_verify(&keypair, signature, (unsigned char *)message,
                              message_len));
}

void test_keypair_signature_hint(void **state) {
  struct Keypair keypair = {
      .public_key = {0x6d, 0xad, 0xcd, 0xfb, 0x9e, 0x98, 0x5b, 0xd,
                     0xc3, 0x21, 0xcb, 0x7d, 0x67, 0xf5, 0x64, 0x43,
                     0xfc, 0x3e, 0x7b, 0x2a, 0x6f, 0x21, 0xae, 0x36,
                     0x21, 0xed, 0x43, 0x6f, 0xff, 0xf8, 0xc9, 0x53},
      .can_sign = false};
  unsigned char expect_hint[] = {0xff, 0xf8, 0xc9, 0x53};

  unsigned char hint[4];
  assert_true(keypair_signature_hint(&keypair, hint));
  assert_memory_equal(expect_hint, hint, 4);
}

void test_keypair_xdr_account_id(void **state) {
  struct Keypair keypair = {
      .public_key = {0x6d, 0xad, 0xcd, 0xfb, 0x9e, 0x98, 0x5b, 0xd,
                     0xc3, 0x21, 0xcb, 0x7d, 0x67, 0xf5, 0x64, 0x43,
                     0xfc, 0x3e, 0x7b, 0x2a, 0x6f, 0x21, 0xae, 0x36,
                     0x21, 0xed, 0x43, 0x6f, 0xff, 0xf8, 0xc9, 0x53},
      .can_sign = false};

  stellarxdr_AccountID accountId;
  assert_true(keypair_xdr_account_id(&keypair, &accountId));
  assert_int_equal(accountId.type, stellarxdr_PUBLIC_KEY_TYPE_ED25519);
  assert_memory_equal(&accountId.stellarxdr_PublicKey_u, keypair.public_key,
                      32);
}

int main() {
  const struct CMUnitTest tests[] = {
      cmocka_unit_test(test_keypair_from_seed),
      cmocka_unit_test(test_keypair_from_secret),
      cmocka_unit_test(test_keypair_from_address),
      cmocka_unit_test(test_keypair_random),
      cmocka_unit_test(test_keypair_address),
      cmocka_unit_test(test_keypair_secret),
      cmocka_unit_test(test_keypair_sign),
      cmocka_unit_test(test_keypair_verify),
      cmocka_unit_test(test_keypair_verify_failed),
      cmocka_unit_test(test_keypair_signature_hint),
      cmocka_unit_test(test_keypair_xdr_account_id),
  };
  return cmocka_run_group_tests(tests, NULL, NULL);
}
