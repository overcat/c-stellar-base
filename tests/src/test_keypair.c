#include <setjmp.h>
#include <stdarg.h>
#include <stddef.h>

#include "../../src/keypair.h"
#include "../../src/strkey.h"
#include <cmocka.h>

void test_keypair_from_seed(void **state) {
  uint8_t seed[] = {0x0,  0xf2, 0x10, 0x94, 0x3e, 0xae, 0xb,  0x3a,
                    0x60, 0x86, 0xab, 0x39, 0x0,  0xa1, 0x23, 0xb2,
                    0xd4, 0x87, 0x8,  0xf6, 0xdf, 0xa9, 0xf6, 0x11,
                    0x62, 0xcd, 0xa7, 0xce, 0x41, 0xf4, 0xce, 0x7a};
  struct Keypair keypair;
  assert_true(keypair_from_seed(&keypair, seed));
  struct Keypair expected_keypair = {
      .seed = {0x0,  0xf2, 0x10, 0x94, 0x3e, 0xae, 0xb,  0x3a, 0x60, 0x86, 0xab,
               0x39, 0x0,  0xa1, 0x23, 0xb2, 0xd4, 0x87, 0x8,  0xf6, 0xdf, 0xa9,
               0xf6, 0x11, 0x62, 0xcd, 0xa7, 0xce, 0x41, 0xf4, 0xce, 0x7a},
      .public_key = {0x6d, 0xad, 0xcd, 0xfb, 0x9e, 0x98, 0x5b, 0xd,
                     0xc3, 0x21, 0xcb, 0x7d, 0x67, 0xf5, 0x64, 0x43,
                     0xfc, 0x3e, 0x7b, 0x2a, 0x6f, 0x21, 0xae, 0x36,
                     0x21, 0xed, 0x43, 0x6f, 0xff, 0xf8, 0xc9, 0x53},
      .can_sign = true};
  assert_true(keypair.can_sign);
  assert_memory_equal(keypair.seed, expected_keypair.seed, 32);
  assert_memory_equal(keypair.public_key, expected_keypair.public_key, 32);
}

void test_keypair_from_secret(void **state) {
  char *seed = "SAAPEEEUH2XAWOTAQ2VTSAFBEOZNJBYI63P2T5QRMLG2PTSB6THHUZXS";
  struct Keypair keypair;
  assert_true(keypair_from_secret(&keypair, seed));
  struct Keypair expected_keypair = {
      .seed = {0x0,  0xf2, 0x10, 0x94, 0x3e, 0xae, 0xb,  0x3a, 0x60, 0x86, 0xab,
               0x39, 0x0,  0xa1, 0x23, 0xb2, 0xd4, 0x87, 0x8,  0xf6, 0xdf, 0xa9,
               0xf6, 0x11, 0x62, 0xcd, 0xa7, 0xce, 0x41, 0xf4, 0xce, 0x7a},
      .public_key = {0x6d, 0xad, 0xcd, 0xfb, 0x9e, 0x98, 0x5b, 0xd,
                     0xc3, 0x21, 0xcb, 0x7d, 0x67, 0xf5, 0x64, 0x43,
                     0xfc, 0x3e, 0x7b, 0x2a, 0x6f, 0x21, 0xae, 0x36,
                     0x21, 0xed, 0x43, 0x6f, 0xff, 0xf8, 0xc9, 0x53},
      .can_sign = true};
  assert_true(keypair.can_sign);
  assert_memory_equal(keypair.seed, expected_keypair.seed, 32);
  assert_memory_equal(keypair.public_key, expected_keypair.public_key, 32);
}

void test_keypair_from_address(void **state) {
  char *address = "GBW23TP3T2MFWDODEHFX2Z7VMRB7YPT3FJXSDLRWEHWUG3777DEVGRVD";
  struct Keypair keypair;
  assert_true(keypair_from_address(&keypair, address));
  struct Keypair expected_keypair = {
      .public_key = {0x6d, 0xad, 0xcd, 0xfb, 0x9e, 0x98, 0x5b, 0xd,
                     0xc3, 0x21, 0xcb, 0x7d, 0x67, 0xf5, 0x64, 0x43,
                     0xfc, 0x3e, 0x7b, 0x2a, 0x6f, 0x21, 0xae, 0x36,
                     0x21, 0xed, 0x43, 0x6f, 0xff, 0xf8, 0xc9, 0x53},
      .can_sign = false};
  assert_true(!keypair.can_sign);
  assert_memory_equal(keypair.public_key, expected_keypair.public_key, 32);
}

void test_keypair_random(void **state) {
  struct Keypair keypair;
  assert_true(keypair_random(&keypair));
  assert_true(keypair.can_sign);
}

void test_keypair_address(void **state) {
  struct Keypair keypair = {
      .public_key = {0x6d, 0xad, 0xcd, 0xfb, 0x9e, 0x98, 0x5b, 0xd,
                     0xc3, 0x21, 0xcb, 0x7d, 0x67, 0xf5, 0x64, 0x43,
                     0xfc, 0x3e, 0x7b, 0x2a, 0x6f, 0x21, 0xae, 0x36,
                     0x21, 0xed, 0x43, 0x6f, 0xff, 0xf8, 0xc9, 0x53},
      .can_sign = false};
  char address[ED25519_PUBLIC_KEY_LENGTH + 1];
  assert_true(keypair_address(&keypair, address));
  char *expected_address =
      "GBW23TP3T2MFWDODEHFX2Z7VMRB7YPT3FJXSDLRWEHWUG3777DEVGRVD";
  assert_string_equal(expected_address, address);
}

void test_keypair_secret(void **state) {
  struct Keypair keypair = {
      .seed = {0x0,  0xf2, 0x10, 0x94, 0x3e, 0xae, 0xb,  0x3a, 0x60, 0x86, 0xab,
               0x39, 0x0,  0xa1, 0x23, 0xb2, 0xd4, 0x87, 0x8,  0xf6, 0xdf, 0xa9,
               0xf6, 0x11, 0x62, 0xcd, 0xa7, 0xce, 0x41, 0xf4, 0xce, 0x7a},
      .public_key = {0x6d, 0xad, 0xcd, 0xfb, 0x9e, 0x98, 0x5b, 0xd,
                     0xc3, 0x21, 0xcb, 0x7d, 0x67, 0xf5, 0x64, 0x43,
                     0xfc, 0x3e, 0x7b, 0x2a, 0x6f, 0x21, 0xae, 0x36,
                     0x21, 0xed, 0x43, 0x6f, 0xff, 0xf8, 0xc9, 0x53},
      .can_sign = true};
  char secret[ED25519_SECRET_SEED_LENGTH + 1];
  assert_true(keypair_secret(&keypair, secret));
  char *expected_secret =
      "SAAPEEEUH2XAWOTAQ2VTSAFBEOZNJBYI63P2T5QRMLG2PTSB6THHUZXS";
  assert_string_equal(expected_secret, secret);
}

int main() {
  const struct CMUnitTest tests[] = {
      cmocka_unit_test(test_keypair_from_seed),
      cmocka_unit_test(test_keypair_from_secret),
      cmocka_unit_test(test_keypair_from_address),
      cmocka_unit_test(test_keypair_random),
      cmocka_unit_test(test_keypair_address),
      cmocka_unit_test(test_keypair_secret),
  };
  return cmocka_run_group_tests(tests, NULL, NULL);
}
